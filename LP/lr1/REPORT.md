# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Лагуткина М. С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     4         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

При указание одинаковых  аргументов Value=Find в предикате change1 возникает зацикливание. Попробуйте запрос, например, change1(2,2,[3,2,4],X). 
Исправьте данный предикат.

## Введение

В Прологе списки имеют иное представление, чем в императивных языках программирования. Например, в Прологе элементы одного списка могут быть разных типов, в отличае от императивных языков программирования. В императивных языках для передвижения по списку и совершения действий с ним и импользуются итераторы, когда как в Прологе список имеет представление "голова-хвост"(или пустой) и обработка элементов происходит рекурсивно. Представление списка в Прологе можно сравнить со стеком, тогда хвост будет лежать в стеке, а в начале будет находиться голова.

## Задание 1.1: Предикат обработки списка

`change1(Value,Find,List,List_ans)` - заменяет все элементы списка с указанным значением на другое значение (на что заменить, что заменить, исходный список, результат).

Примеры использования:
```prolog
?- change1(2,1,[1,2,3,4,1],X).
X = [2, 2, 3, 4, 2] ;
false.
?- change1(1,2,[],Y).
Y = [] ;
false.
?- change1(2,Y,[3,2,1,3,4],X).
Y = 3,
X = [2, 2, 1, 2, 4] ;
false.
?- change1(2,2,[3,2,4],X).
X = [3, 2, 4] ;
false.
```

Реализация:
```prolog
change1(V,F,[],[]).
change1(V,F,[F|T],[V|T1]):-!, change1(V,F,T,T1).
change1(V,F,[Y|T],[Y|T1]):- change1(V,F,T,T1).
```
Реализация с использованием стандартных предикатов:
```prolog
change2(X, Y, [], []).
change2(X, Y, [Y|T], Ans) :- change2(X, Y, T, T1), append1([X], T1, Ans).
change2(X, Y, [H|T], Ans) :- H \= Y, change2(X, Y, T, T1), append1([H], T1, Ans).
```
Предикат рекурсивно идет по списку, если встречается в голове списка элемент равный данному, то этот элемент заменяется, иначе замена не производтся.
В реализации со стандартным предикатом, замена элемента производится через конкатенацию списков.

## Задание 1.2: Предикат обработки числового списка

`split1(List, List1_ans, List2_ans)` - разделяет список на два по порядковому принципу (первый-второй).

Примеры использования:
```prolog
?- split1([1,2,3,4,5,6,7],X,Y).
X = [1, 3, 5, 7],
Y = [2, 4, 6].
?- split1(X,[1,1,1,1,1],[2,2,2,2]).
X = [1, 2, 1, 2, 1, 2, 1, 2, 1].
?- split1(X,[1,1,1,1,1],[2]).
X = [1, 2, 1, 1, 1, 1].
```

Реализация:
```prolog
split1([A,B|T],[A|T1],[B|T2]):-!,split1(T,T1,T2).
split1(A,A,[]):-!.
```
Предикат рекурсивно идет по списку, разделяя элементы по очереди на два списка.

Пример совместного использования:

`task(List,Value,Answer)` - создает список в 2 раза меньше исходного и изменяет указанное значение на значением первого элемента исходного списка.

Примеры использования:
```prolog
?- task([1,2,3,3,4,3,3,3,2,4],3,A).
A = [2, 1, 1, 1, 4] ;
false.
?- task([1,2,3,3,4,3,3,3,2,4],X,A).
X = 2,
A = [1, 3, 3, 3, 4] ;
false.
```

Реализация:
```prolog
task(L,X,Ans):-split1(L,[H|T],L2),change1(H,X,L2,Ans).
```
Сначала производится рекурсивное разделение исходного списка на два новых, заменяется значения X во втором списке на значения первого элемента первого списка, т. е. на H.

## Задание 2: Реляционное представление данных

 К преимуществам реляционного представления можно отнести то, что удобно хранить информацию и то, что представление связи между данными в виде правил достаточно понятно и просто обрабатывается. К недостаткам можно отнести то, что такое представление занимают больший объем памяти, чем нереряционное представление.

В задании использовалось релячионное представление `three.pl`.

Задание 1: Для каждого студента, найти средний балл, и сдал ли он экзамены или нет.
Поиск среднего балла реализуется с помощью предиката `average_marks_for_stud(Student, Average_marks)`, а сдал ли студент экзамены - с помощью `successfull_exams(Student)`.

Примеры использования:
```prolog
?- average_marks_for_stud('Ивановский',X).
X = 3.5.
?- average_marks_for_stud(X,4).
X = 'Петров' ;
X = 'Иванов' ;
X = 'Сидоров' ;
X = 'Биткоинов' ;
X = 'Программиро' ;
X = 'Круглотличников'.
?- successfull_exams('Сидоров').
false.
?- successfull_exams(X).
X = 'Петров' ;
X = 'Иванов' ;
X = 'Ивановский' ;
X = 'Биткоинов' ;
X = 'Эфиркина' ;
X = 'Сиплюсплюсов' ;
X = 'Программиро' ;
X = 'Джаво' ;
X = 'Фулл' ;
X = 'Безумников' ;
X = 'Решетников' ;
X = 'Эксель' ;
X = 'Текстописова' ;
X = 'Густобуквенникова' ;
X = 'Криптовалютников' ;
X = 'Вебсервисов' ;
X = 'Круглотличников'
```

Реализация:
```prolog
% сумма элементов в списке
sum([],0). 
sum([grade(_,Mark)|T],Sum):-sum(T,RSum), Sum is RSum + Mark.

%Для каждого студента, найти средний балл (студент, средняя оценка)
average_marks_for_stud(Student, Average_marks):-student(_,Student,Marks_list),
    sum(Marks_list,Sum),lenght(Marks_list,Len),Average_marks is Sum/Len.

%Сдал ли студент экзамены. True в случае успешной сдачи всех экзаменов
successfull_exams(Student):-student(_,Student,Marks_list),not(member(grade(_,2),Marks_list)).
```
Для нахождения среднего балла студента выполняется поиск списка оценок по студентам, далее вычисляется сумма всех оценок в списке, затем вычисляется длина списка, т. е. количество оценок, после этого вычисляется средний балл. Для ответа на запрос сдал ли студент экзамены выполняется поиск списка оценок, далее проверяется условие есть ли в списке оценок двойки. 

Задание2: Для каждого предмета, найти количество не сдавших студентов.
Для этого реализован предикат `count_stud_for_subjects(Subject,Counting_students)`.

Примеры использования:
```prolog
?- count_stud_for_subjects(A,B).
A = 'Логическое программирование',
B = 0 ;
A = 'Математический анализ',
B = 3 ;
A = 'Функциональное программирование',
B = 3 ;
A = 'Информатика',
B = 3 ;
A = 'Английский язык',
B = 2 ;
A = 'Психология',
B = 3.
?- count_stud_for_subjects(X,0).
X = 'Логическое программирование' .
```

Реализация:
```prolog
% Для каждого предмета, найти количество не сдавших студентов
count_stud_for_subjects(Subject,Count_stud):- subject(Abb_subj,Subject),
    findall(Marks_list,(student(_,_,Marks_list),list_grade(Marks_list,Abb_subj)),All_marks),length(All_marks,Count_stud).

list_grade([grade(Abb_subj,2)|_],Abb_subj).
list_grade([_|T],Abb_subj):-list_grade(T,Abb_subj).
```
Для нахождения количества студентов выделяется аббревиатура предмета, далее находится список двоек для предмета, затем вычисляется его длина, т.е. количество студентов.

Задание 3: Для каждой группы, найти студента (студентов) с максимальным средним баллом.
Для этого реализован предикат `average_stud_for_group(Group,Student)`.

Примеры использования:
```prolog
?- average_stud_for_group(104,X).
X = ['Фулл'].
```

Реализация:
```prolog
%Для каждой группы, найти студента (студентов) с максимальным средним баллом
average_stud_for_group(Group,Student):-
  findall(Av_mark,(student(Group,Stud,_),average_marks_for_stud(Stud,Av_mark)),All_av_marks),max(All_av_marks, Max_av_mark),
  findall(St,(student(Group,St,_),average_marks_for_stud(St,Tmp),Tmp =:= Max_av_mark),Student),!. 

% нахождение мвксимального числа из списка
max([],0).
max([H|T],Max_num):-max(T,Tmp_num),H >=Tmp_num, Max_num is H.
max([H|T],Max_num):-max(T,Tmp_num),H =< Tmp_num, Max_num is Tmp_num.
```
Дл нахождения студента группы с максимальным средним баллом для указанное группы создается список всех средних баллов для группы, из них ищется максимальный, затем производится поиск студента по найденному максимальному среднему баллу.

## Выводы

Данная лабораторная работа показала новые возможности языка Пролог. В частности принципы работы со списками в Прологе. Меня удивила сама реализация списка, она совершенно другая, непохожая на реализацию в императивных языках программирования. По-началу было непонятно, зачем нужен список, как "голова-хвост", но, при самостоятельной написании предикатов обработки списка, стало понятно, насколько реализация "голова-хвост" важна для различной обработки списка. Таже были некоторые сложности в реализации предикатов для первого задания, например, сначала получался не совсем корректный вывод в change1, но потом я решила проблему. В целом, возникали сложности не в самом алгоритме выполнения задания, а в его реализации.  Позже, при оформлении отчета, было интересно больше поработать со своим кодом, пробовать задавать нестандартные запросы на обработку списка. 



