# Отчет по курсовому проекту
## по курсу "Логическое программирование"

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| |              |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Грамматика в 5 п.
## Введение

При выполнении заданий курсового проека, самое главное, что я получила - это практика программирования на Прологе. 
Также я познакомилась с форматом GedCom у которого, по сути, нет аналогов. Я познакомилась с таким языком программирования, как Python.  Закрепила знания, поученные в лабораторных работах 3 и 4, которые мне пригодились для реализации поиска в пространстве состояний и грамматическом разборе предложений. 


## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `parents(потомок, отец, мать)`
 3. Реализовать предикат проверки/поиска троюродного брата или сестры 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я получила родословное дерево с помощью сайта MyHeritage.com, в нем 18 человек. После чего экспортировала это дерево в формат GEDCOM.

## Конвертация родословного дерева

Для преобразования дерева из формата GEDCOM в указанное в задании представление `parents(потомок, отец, мать)`, я использовала язык Python, так как он достаточно просто позволяет проводить обработку текста, а значит наиболее подходит для решения задачи. До решения данной задачи, я не сталкивалась с Python,но было интересно, зная язык на нулевом уровне, попробовать написать парсер текста. На удивление написание программы заняло достаточно мало времени. И я не пожалела, что выбрала именно Python, хотя и изначально я хотела написать парсер на Prolog'е, но из-за того, что былир и другие лабораторные, которые нужно делать, я отказалась от этой идеи. 

Программа считывает текст построчно, и в зависимости от того, что встречено в строке, обрабатываются последущие данные. Ключевые слова в строке находятся с помощью `find`, далее если строка подходит под одно из условий она разбивается по пробелам на массив слов с помощью `split`, после чего нужные данные записываются в конец одного из массивов с помощью `append`. В массивы сохраняются имя, фамилия, а также ссылки на детей и родителей человека.

Далее после считывания данных из файла, начинается преобразование в заданный формат. Итерируясь по массивам ссылок на детей и родителей, ищем совпадения, или остутствие ссылок и пишем данные в выходной файл в указанном формате. 

## Предикат поиска родственника

Мой преддикат поиска троюродных брата или сестры устроем очень просто. После определения предиката `sibling(Person1, Person2)`, я определяю  аналогично sibling второго уровня, то есть двоюродных брата или сестру, а затем sibling третьего уровня, который и будет нужным предикатом для решения задачи.
```prolog
sibling_1(X,Y) :- parents(X,A,B),parents(Y,A,B), X\=Y.
sibling_2(C,D) :- parents(C,X,_),parents(D,Y,_),sibling_1(X,Y).
sibling_2(C,D) :- parents(C,_,X),parents(D,Y,_),sibling_1(X,Y).
sibling_2(C,D) :- parents(C,X,_),parents(D,_,Y),sibling_1(X,Y).
sibling_2(C,D) :- parents(C,_,X),parents(D,_,Y),sibling_1(X,Y).
sibling_3(E,F) :- parents(E,C,_),parents(F,D,_),sibling_2(C,D).
sibling_3(E,F) :- parents(E,_,C),parents(F,D,_),sibling_2(C,D).
sibling_3(E,F) :- parents(E,C,_),parents(F,_,D),sibling_2(C,D).
sibling_3(E,F) :- parents(E,_,C),parents(F,_,D),sibling_2(C,D).
```
Результаты работы программы:
```prolog
?- sibling_3('Maria Lagutkina',X).
X = 'Artem Vasiliev' ;
false.
?- sibling_3(X,'Natalia Namestnikova').
false.
?- sibling_3(X,Y).
X = 'Maria Lagutkina',
Y = 'Artem Vasiliev' ;
X = 'Artem Vasiliev',
Y = 'Maria Lagutkina' ;
false.
```

## Определение степени родства

Для решения данной задачи мне потребовалось доопределить пол людей в дереве, у которых нет детей. Для всех остальных пол легко определяется порядком аргументов в предикате `parents(потомок, отец, мать)`. Это нужно для того, чтобы определять отношения "родитель-сын"("родитель-дочь"), "брат-сестра". Вообще здесь можно обойтись и без введения дополнительных данных, и указанные отношения станут "родитель-ребенок" и "брато-сестра". Однако введение пола все равно необходимо для реализации естесственно-языкового интерфейса.
Поиск цепи родственников производится через поиск в ширину, так как по этому алгоритму исключается возможность ухода в бесконечный цикл, поэтому он подходит для решения задачи.
Сначала составляется список пройденных узлов, затем они заменяются на отношения между этими людьми.
```prolog
bfs_relative(X, Y, Res):- bfs_search([[X]],Y, L), reverse(L, Res).

bfs_search([[End|T]|_], End, [End|T]).
bfs_search([Next|B], End, Ans):- findall(Z,prolong(Next,Z),T), append(B,T,Bn), bfs_search(Bn,End,Ans).
bfs_search([_|T], End, Ans):- bfs_search(T, End, Ans).

relative(X, Y, Res):- bfs_relative(X, Y, Res1), !, name_to_relation(Res1, Res).
```
Результаты работы программы:
```prolog
?- relative('Maria Lagutkina','Artem Vasiliev',X).
X = [child, child, sister, father, father].

?- relative('Ilia Vasiliev','Nataliia Lagutkina',X).
X = [father, mother, husband].
```
В первом случае выведено решение - троюродный брат. Во втором случае степень родства - это отец матери мужа.
## Естественно-языковый интерфейс
Сначала описываются возможные родственные связи, а также проверка на допустимое отношение родства `number_of_relation(X)`. Это нужно для разбора возможных запросов. Вводится список из слов вопроса, разбирается, проверяется на корректность с помощью предиката `response_to_request`: здесь тип вопроса определяется по первому слову, затем направляется в предикат для этого типа вопроса. Я сделала предикаты на 3 типа вопросов, в каждом из которых по вопросу с упоминанием всех лиц на счет которых задан вопрос и с косвенным упоминанием.
Также реализована возможность ввода прилагательных перед глаголами. Словарь прилагательных выглядит так:
```prolog
is_adj(X):-member(X, [good,bad,beautiful]).
```
Для того, чтобы использовать прилагательные (или можно без них), вначале разбирается чать вопроса до прилагательного, а затем распарсивается хвост списка.
Для того, чтобы можно было обатиться в вопросе косвенно к человеку (запомнить последнее имя к которому было обращение), используется предикаты `nb_setval` и `nb_getval`.
Пример одного из предикатов для ответа на вопрос:
```prolog
%[how, many,<adjective>(or nothing), <relation>, does, <person> , has , ?]
response_to_request_how1([QW, Qual,Adjective | T]):-
      how_or_who(QW), many_or_much(Qual), 
      (is_adj(Adjective), list1(T,Relation, Does, Name1, Has, Q);  shift(Relation,Adjective),list2(T,Does, Name1, Has, Q)),
      is_plural(Relation), 
      does(Does), 
      (sex(Name1, m);sex(Name1, f)), has(Has), question_mark(Q),!,
      nb_setval(last_name, Name1),
      plural_to_singular(Rel, Relation),
      setof(X, relative_in_names(X, Name1, Rel),L),
      length(L, Len),!,

      write(Name1), write(" has "),
      ((Len =:= 1, write(Len), write(" "), write(Rel));(Len \= 1, write(Len), write(" "), write(Relation))),!.
```
Результаты работы программы:
```prolog
?- response_to_request([who,is,'Nataliia Lagutkina',"'s",brother,?]).
Alexander Namesnikov is Nataliia Lagutkina's brother
true.
?- response_to_request([who,is,her,beautiful,daughter,?]).
Maria Lagutkina is Nataliia Lagutkina's daughter
true.
?- response_to_request([how,many,good,brothers,does,'Pavel Vasiliev',have,?]).
Pavel Vasiliev has 1 brother
true.
?- response_to_request([how,many,sons,does,he,has,?]).
false.
?- response_to_request([is,'Alexandra Vasilieva',his,mother,?]).
true.
?- response_to_request([is,'Alexander Vasiliev','Ilia Vasiliev',"'s", good,son,?]).
true.
?- response_to_request([how,many,sons,does,he,has,?]).
Ilia Vasiliev has 1 son
true.
```

## Выводы

Часть того, чему я научилась я описала во введении, также хотелось бы добавить, что так как в 3-ей лабораторной у меня был разбор арифметического выражения и все-таки это имело меньшее отношение к естественно-языковому интерфейсу, последнее задание в курсовой позволило взглянуть по-новому на разбор предложений, я поняла, насколько обширны возможности обработки естественного языка на Прологе.

Также я стала более осознанно подходить к выбору алгоритмов для решения задачи на Прологе, использовать отсечения решений, чтобы программа работала именно так, как нужно.
При написания реферата я узнала где сейчас применяют логическое программирование, а также немного о других логических языках. Было интересно узнать о контретных программах, для написания которых был использован логический язык.
